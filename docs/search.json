[
  {
    "objectID": "posts/systemd-nspawn-dev-env/index.html",
    "href": "posts/systemd-nspawn-dev-env/index.html",
    "title": "the dev environment with systemd-nspawn",
    "section": "",
    "text": "background\nI am an Arch user motivated by its super active community. However, many stuff in academy or industry extremely those about Robotics are designed for the Ubuntu. The ROS AUR package is out-of-date. It is difficult to maintain a package with so many dependencies. Furthermore, many libraries about pointcloud processing and navigation are developed under ubuntu, which means developers of those libs only maintain for Ubuntu usually.\n\n\ncreate Ubuntu environment\n\ndebootstrap\n\nparu -S debootstrap\n\nTo manage the container with machinectl, create the Ubuntu environment in the /var/lib/machines/ with root permission.\n\n\ndebootstrap --include=dbus,systemd-container --components=main,universe,multiverse jammy jammy https://mirrors.tuna.tsinghua.edu.cn/ubuntu\n\nEnter the container with systemd-nspawn -D jammy\nThe network of Ubuntu might be broken now.\n\nconfigure systemd-resolved. Edit the /etc/systemd/resolved.conf DNS line DNS=8.8.8.8\n(optionally) configure DNS manually\n\nsudo systemctl disable --now systemd-resolved\necho 'nameserver 8.8.8.8' &gt; /etc/resolv.conf\n\n\n\nAt first, I tried podman(docker) for a period of time. I think they are so heavy. I don’t care about the image, I just require a container that can run Ubuntu and the faster the better. I don’t mind the dirty directories. That’s why I choose systemd-nspawn in the end\n\n\npassthrough Nvidia GPU\nAnother requirement is the discrete Nvidia gpu on my laptop, some of the development using CUDA. ArchWiki Systemd-nspawn#Nvidia_GPUs Create file /etc/systemd/system/systemd-nspawn@.service.d/nvidia-gpu.conf\n[Service]\nExecStart=\nExecStart=systemd-nspawn --quiet --keep-unit --boot --link-journal=try-guest --machine=%i \\\n--bind=/dev/dri \\\n--bind=/dev/shm \\\n--bind=/dev/nvidia0 \\\n--bind=/dev/nvidiactl \\\n--bind=/dev/nvidia-modeset \\\n--bind=/usr/bin/nvidia-bug-report.sh:/usr/bin/nvidia-bug-report.sh \\\n--bind=/usr/bin/nvidia-cuda-mps-control:/usr/bin/nvidia-cuda-mps-control \\\n--bind=/usr/bin/nvidia-cuda-mps-server:/usr/bin/nvidia-cuda-mps-server \\\n--bind=/usr/bin/nvidia-debugdump:/usr/bin/nvidia-debugdump \\\n--bind=/usr/bin/nvidia-modprobe:/usr/bin/nvidia-modprobe \\\n--bind=/usr/bin/nvidia-ngx-updater:/usr/bin/nvidia-ngx-updater \\\n--bind=/usr/bin/nvidia-persistenced:/usr/bin/nvidia-persistenced \\\n--bind=/usr/bin/nvidia-powerd:/usr/bin/nvidia-powerd \\\n--bind=/usr/bin/nvidia-sleep.sh:/usr/bin/nvidia-sleep.sh \\\n--bind=/usr/bin/nvidia-smi:/usr/bin/nvidia-smi \\\n--bind=/usr/bin/nvidia-xconfig:/usr/bin/nvidia-xconfig \\\n--bind=/usr/lib/gbm/nvidia-drm_gbm.so:/usr/lib/x86_64-linux-gnu/gbm/nvidia-drm_gbm.so \\\n--bind=/usr/lib/libEGL_nvidia.so:/usr/lib/x86_64-linux-gnu/libEGL_nvidia.so \\\n--bind=/usr/lib/libGLESv1_CM_nvidia.so:/usr/lib/x86_64-linux-gnu/libGLESv1_CM_nvidia.so \\\n--bind=/usr/lib/libGLESv2_nvidia.so:/usr/lib/x86_64-linux-gnu/libGLESv2_nvidia.so \\\n--bind=/usr/lib/libGLX_nvidia.so:/usr/lib/x86_64-linux-gnu/libGLX_nvidia.so \\\n--bind=/usr/lib/libcuda.so:/usr/lib/x86_64-linux-gnu/libcuda.so \\\n--bind=/usr/lib/libnvcuvid.so:/usr/lib/x86_64-linux-gnu/libnvcuvid.so \\\n--bind=/usr/lib/libnvidia-allocator.so:/usr/lib/x86_64-linux-gnu/libnvidia-allocator.so \\\n--bind=/usr/lib/libnvidia-cfg.so:/usr/lib/x86_64-linux-gnu/libnvidia-cfg.so \\\n--bind=/usr/lib/libnvidia-egl-gbm.so:/usr/lib/x86_64-linux-gnu/libnvidia-egl-gbm.so \\\n--bind=/usr/lib/libnvidia-eglcore.so:/usr/lib/x86_64-linux-gnu/libnvidia-eglcore.so \\\n--bind=/usr/lib/libnvidia-encode.so:/usr/lib/x86_64-linux-gnu/libnvidia-encode.so \\\n--bind=/usr/lib/libnvidia-fbc.so:/usr/lib/x86_64-linux-gnu/libnvidia-fbc.so \\\n--bind=/usr/lib/libnvidia-glcore.so:/usr/lib/x86_64-linux-gnu/libnvidia-glcore.so \\\n--bind=/usr/lib/libnvidia-glsi.so:/usr/lib/x86_64-linux-gnu/libnvidia-glsi.so \\\n--bind=/usr/lib/libnvidia-glvkspirv.so:/usr/lib/x86_64-linux-gnu/libnvidia-glvkspirv.so \\\n--bind=/usr/lib/libnvidia-ml.so:/usr/lib/x86_64-linux-gnu/libnvidia-ml.so \\\n--bind=/usr/lib/libnvidia-ngx.so:/usr/lib/x86_64-linux-gnu/libnvidia-ngx.so \\\n--bind=/usr/lib/libnvidia-opticalflow.so:/usr/lib/x86_64-linux-gnu/libnvidia-opticalflow.so \\\n--bind=/usr/lib/libnvidia-ptxjitcompiler.so:/usr/lib/x86_64-linux-gnu/libnvidia-ptxjitcompiler.so \\\n--bind=/usr/lib/libnvidia-rtcore.so:/usr/lib/x86_64-linux-gnu/libnvidia-rtcore.so \\\n--bind=/usr/lib/libnvidia-tls.so:/usr/lib/x86_64-linux-gnu/libnvidia-tls.so \\\n# not exist in my machine. --bind=/usr/lib/libnvidia-vulkan-producer.so:/usr/lib/x86_64-linux-gnu/libnvidia-vulkan-producer.so \\\n--bind=/usr/lib/libnvoptix.so:/usr/lib/x86_64-linux-gnu/libnvoptix.so \\\n--bind=/usr/lib/modprobe.d/nvidia-utils.conf:/usr/lib/x86_64-linux-gnu/modprobe.d/nvidia-utils.conf \\\n--bind=/usr/lib/nvidia/wine/_nvngx.dll:/usr/lib/x86_64-linux-gnu/nvidia/wine/_nvngx.dll \\\n--bind=/usr/lib/nvidia/wine/nvngx.dll:/usr/lib/x86_64-linux-gnu/nvidia/wine/nvngx.dll \\\n--bind=/usr/lib/nvidia/xorg/libglxserver_nvidia.so:/usr/lib/x86_64-linux-gnu/nvidia/xorg/libglxserver_nvidia.so \\\n--bind=/usr/lib/vdpau/libvdpau_nvidia.so:/usr/lib/x86_64-linux-gnu/vdpau/libvdpau_nvidia.so \\\n--bind=/usr/lib/xorg/modules/drivers/nvidia_drv.so:/usr/lib/x86_64-linux-gnu/xorg/modules/drivers/nvidia_drv.so \\\n--bind=/usr/share/X11/xorg.conf.d/10-nvidia-drm-outputclass.conf:/usr/share/X11/xorg.conf.d/10-nvidia-drm-outputclass.conf \\\n--bind=/usr/share/dbus-1/system.d/nvidia-dbus.conf:/usr/share/dbus-1/system.d/nvidia-dbus.conf \\\n--bind=/usr/share/egl/egl_external_platform.d/15_nvidia_gbm.json:/usr/share/egl/egl_external_platform.d/15_nvidia_gbm.json \\\n--bind=/usr/share/glvnd/egl_vendor.d/10_nvidia.json:/usr/share/glvnd/egl_vendor.d/10_nvidia.json \\\n--bind=/usr/share/licenses/nvidia-utils/LICENSE:/usr/share/licenses/nvidia-utils/LICENSE \\\n--bind=/usr/share/vulkan/icd.d/nvidia_icd.json:/usr/share/vulkan/icd.d/nvidia_icd.json \\\n--bind=/usr/share/vulkan/implicit_layer.d/nvidia_layers.json:/usr/share/vulkan/implicit_layer.d/nvidia_layers.json \\\nDeviceAllow=/dev/dri rw\nDeviceAllow=/dev/shm rw\nDeviceAllow=/dev/nvidia0 rw\nDeviceAllow=/dev/nvidiactl rw\nDeviceAllow=/dev/nvidia-modeset rw\n\n\nusage\nsudo machinectl start jammy\nsudo machinectl poweroff jammy\nsudo machinectl enable jammy # auto-start\n\n\ninstall package\n\nupdate modify /etc/apt/source.list, add jammy-updates and jammy-backports\n\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse\nthen, \nsudo apt update\n\ncuda\naccording to this, we just need to install the required cuda-toolkit in the container regardless the cuda in the host Arch.\nfollowing Nvidia’s instruction install the specific version of cuda-toolkit.\nros\njust following the ROS wiki everything will work correctly.\n\n\n\nGUI\nUsing Wayland, to use GUI, just let the DISPLAY env in the container equal to its value in the host without binding anything specifically.\n\n\nat least it runs well on my machine\nexport DISPLAY=:1\n\n\nreference\nhttps://wiki.archlinux.org/title/Systemd-nspawn\nhttps://www.kxxt.dev/blog/systemd-nspawn-container-for-ros"
  },
  {
    "objectID": "posts/rust-os/async-impls-comparison.html",
    "href": "posts/rust-os/async-impls-comparison.html",
    "title": "async implementations comparison",
    "section": "",
    "text": "embassy\n编译期确定状态的内存空间（任务池）heapless\n利用rust的future相关trait实现\n调度器在await发生时poll该future的执行状态\n结合::core::task实现\n\n\ngreen thread\n由任务通过yield返回到调度器，通过调度器修改寄存器来实现状态记录与切换\n\n\nio_uring\nref\n通过SQ(submission queue) CQ(completion queue)两个ring queue实现的异步"
  },
  {
    "objectID": "posts/bluetooth-low-energy/ble.html",
    "href": "posts/bluetooth-low-energy/ble.html",
    "title": "BLE",
    "section": "",
    "text": "The BLE protocol is commonly used but complex, so I decided to glance at its framework.\n\nTBD: security, sniffer. course site\n\nBasic Concepts:\n\nProtocol Stack \nHost\n\nL2CAP(Logical Link Control & Adaptaion Protocol): encapsulating service for upper layers\nSMP(Security Manager Protocol): defines and provides secure communication\nATT(Attribute Protocol): pieces of data exposed to other devices\nGATT(Generic Attribute Profile): sub-procedures for using the the ATT layer\nGAP(Generic Access Profile): devices discovery and connection-related services\n\nController:\n\nPHY(Physical Layer): modulate datas onto the waves and receive data from waves\nLL(Link Layer): manage the state(standby, advertising, scanning, initialing, connection) of the radio\n\nRoles\n\nAdvertising & Scanning\nCentral & Peripheral\nThe central scans the packets advertising by the peripherals and can initial a connection by sending a connection request.\nPeripheral generally use less power than central\nBroadcast & Observer Broadcast & Listen advertisement without connection.\n\nGATT\n\nServer: store data and provide methods for client to access data.\nClient: access data on the server\nAttribute: a standard data representation format\nThe Generic Attribute Profile \nGATT defined by the Bluetooth SIG(Special Interest Group)\n\nRadio Modes\n\n1M PHY / 2M PHY: xMbps\ncoded PHY: S symbols represent 1 bit to achieve longer communication.\n\n\nAdvertising\n\nchannels: 40 channels in BLE, 3 primary channels is mainly for advertisement and 37 secondary channels mainly used for data transfer after connecting.\nScan Interval & Scan Window(the time in each interval)\nScan Request & Response:\n\nRequest: sent by central to request extra information without adevertising\nResponse: respond to a scan request \n\nExtended advertising: the primary advertisement channels are pointing to supplementary information that is being advertised on the secondary advertisement channel.\ntypes:\n\nconnectable & non-connectable\nscannable & non-scannable\ndirected & undirected\n\nAddress: a unique 48-bit address\n\nPublic address: pay and register with IEEE registration authority\nRandom address:\n\nstatic or private\nprivate: resolvable or non-resolvable\nresolvable: use a pre-shared key IRK(Identity Resolving Key) to generate and resolve the random address.\n\n\nPacket Structure\n\nPDU(Protocol Data Unit):\n\nAdvertising (channel) PDU\nData (channel) PDU \n\nAdvertisement PDU Header \n\nRFU: Reserved for future use\nChSel: set to 1 if LE Channel Selection Algorithm #2 is supported\nTxAdd: 0/1. transmitter address is public or random\nRxAdd: 0/1. receiver address is public or random\nLength: payload length\n\nAdvertisement PDU Payload \n\nAdvA: Bluetooth address of the advertising device (48bits)\nAdvData: data packet\n\n\n\nConnection\n\nDisconnect: by application, by supervision timeout\nParameters:\n\nConnection interval\n\nSupervision timeout: successfully receiving the last packet before the connection is considered lost\nPeripheral latency: allow skip waking up for a certain number of connection events if it doesn’t have any data to send\nPHY radio modes: 1/2M, coded PHY\nData Length & MTU(Maximum Transfer Unit): MTU is the number of bytes that can be sent in one GATT operation. Data Length is the number of bytes can be sent in one BLE packet.\n\nDLE(Data Length Extension): allow the data length increases from 27 bytes to 251 bytes to save time and power.\n\nUpdate the connection parameters\n\nconnection interval, supervision timeout and peripheral latency: directed by the central, but the peripheral can request changes\nPHY radio modes, data length and MTU: set to the default values when a connection is first established. Either device can request to update the parameters, the other device will then either its supported values or state it is not supported.\n\n\n\nData Exchange in BLE\n\nGATT operations\n\nclient-initiated: read, write, write without response\nserver-initiated: notify, indicate(an acknowledgement is required from client)\nThough the operations initiated by the server, the client is required to enable them first by subscribing the characteristic and enabling either notifications or indications.\n\nATT layer\n\nAttributes \n\nHandle: 16-bit unique index in the attribute table assigned by the stack\nUUID: universally unique id tell the attribute type\n\nFirst Type: SIG defined 16-bit UUID\nSecond Type: vendor-specific 128-bit UUID. Insert custom 16-bit IDs in the base UUID\n\nPermission: sercurity level(encryption and authorization)\nValue: the actual data or the information about other attributes\n\nServices and Characteristics\n\nService \n\nService declaration attribute: starts a service\nCharacteristic definition attribute:\n\nCharacteristic declaration attribute: holds the metadata about the Characteristic value attribute\nCharacteristic value attribute: holds the actual user data\nCharacteristic descriptor attribute(optional): holds more metadata about the characteristics\n\nCCCD(Client Characteristic Configuration Descriptor): writable for client to enable/disable server-initiated operations notify and indicate"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "A Sleepy Student?"
  },
  {
    "objectID": "about.html#who-am-i",
    "href": "about.html#who-am-i",
    "title": "About",
    "section": "",
    "text": "A Sleepy Student?"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hello?",
    "section": "",
    "text": "Rust Embedded OS and HAL about Async\n\n\n\nnotes\n\n\n\n\n\n\n\n\n\nMay 10, 2025\n\n\ndrindr\n\n\n\n\n\n\n\n\n\n\n\n\nasync implementations comparison\n\n\n\nnotes\n\n\n\n\n\n\n\n\n\nMay 9, 2025\n\n\ndrindr\n\n\n\n\n\n\n\n\n\n\n\n\nBLE\n\n\n\nnotes\n\n\n\n\n\n\n\n\n\nApr 5, 2025\n\n\ndrindr\n\n\n\n\n\n\n\n\n\n\n\n\niterative closest point(icp)\n\n\n\nnotes\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\ndrindr\n\n\n\n\n\n\n\n\n\n\n\n\nthe dev environment with systemd-nspawn\n\n\n\nposts\n\n\n\n\n\n\n\n\n\nAug 24, 2024\n\n\ndrindr\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/icp/index.html",
    "href": "posts/icp/index.html",
    "title": "iterative closest point(icp)",
    "section": "",
    "text": "TBD\nvideo site\ntarget: align 2 points into the same frame"
  },
  {
    "objectID": "posts/icp/index.html#part1-data-association-svd",
    "href": "posts/icp/index.html#part1-data-association-svd",
    "title": "iterative closest point(icp)",
    "section": "PART1: Data Association & SVD",
    "text": "PART1: Data Association & SVD\n\ndirect and optimal solution: \\(\\sum||y_n - \\bar{x}_n||^2p_n \\rightarrow min\\)\n\nproperties: no initial guess and no better solution exist\nweighted sums: \\(x_0 = \\frac{\\sum x_n p_n}{\\sum p_n}\\) and \\(y_0 = \\frac{\\sum y_n p_n}{\\sum p_n}\\)\ncross-correlation matrix: \\(H = \\sum (y_n - y_0)(x_n - x_0)^T p_n\\)\n\\(svd(H) = UDV^T\\)\n\\(\\Rightarrow R=VU^T, t = y_0 - Rx_0\\)\nuse the local coordinates defined by the point set (set the origin as weighted mean \\(y_0\\))\n\\(\\sum ||(y_n - y_0) - (R x_n + t - y_0)||^2 p_n \\rightarrow min\\)\nstart with \\(\\bar{x}_n - y_0 = Rx_n + t - y_0\\)\nrewrite the translation \\(\\bar{x}n  - y_0 = R(x_n + R^Tt - R^Ty_0)\\)\nintroduce a new variable \\(x_0 = R^Ty_0 - R^Tt\\)\n\\(\\bar{x}_n - y_0 = R(x_n - x_0)\\)\nminimization problem: \\(R^*, x^*_0 = \\underset{R, x_0}{argmin}\\sum || y_n - y_0 - R(x_n - x_0) ||^2 p_n\\)\nobjective function: \\(\\Phi(x_0, R) = \\sum [(y_n - y_0) - R(x_n - x_0)]^T[(y_n - y_0) - R(x_n - x_0)] p_n\\)\nlet \\(\\frac{\\delta \\Phi}{\\delta x_0} = 0 \\Rightarrow x_0 = \\frac{\\sum x_np_n}{p_n}\\)\nthen let \\(\\frac{\\delta \\Phi}{\\delta x_0} = 0 \\Rightarrow R^* = \\underset{R}{argmax}\\sum b_n^TRa_np_n\\) \\((b_n = y_n - y_0, a_n = x_n - x_0)\\)\nusing the trace?: \\(R^* = \\underset{R}{argmax}\\ tr(RH)\\)\n\\(H\\) is the covariance matrix: \\(H = \\sum (a_nb_n^T)p_n\\)"
  },
  {
    "objectID": "posts/rust-os/async-related-os-and-hal.html",
    "href": "posts/rust-os/async-related-os-and-hal.html",
    "title": "Rust Embedded OS and HAL about Async",
    "section": "",
    "text": "Note\n\n\n\n\n\n.\n├── arch\n│   ├── aarch64 （arm相关：cortex-m-rt？）\n│   │   └── ...\n│   ├── loongarch64\n│   │   └── ...\n│   ├── mod.rs\n│   ├── riscv （riscv-rt？）\n│   │   └── ...\n│   └── x86_64\n│       └── ...\n├── cpu.rs （core，核心相关）\n├── irq.rs （中断相关）\n├── lib.rs\n├── mem.rs （物理内存管理）\n├── paging.rs （内存分页相关）\n├── platform\n│   └── ... (特定平台的实现)\n├── time.rs \n├── tls.rs (✖线程内存，应由multitask模块提供？)\n└── trap.rs （特权态相关）\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nmain crate\n├── delay.rs\n├── digital.rs\n├── i2c.rs\n├── lib.rs\n├── pwm.rs\n└── spi.rs\n\nnon-blocking crate\n├── lib.rs\n├── serial.rs\n└── spi.rs\n\nasync crate\n├── delay.rs\n├── digital.rs\n├── i2c.rs\n├── lib.rs\n└── spi.rs\n\nbus crate (提供bus的共享实现)\n├── i2c\n│   ├── atomic.rs\n│   ├── critical_section.rs\n│   ├── mod.rs\n│   ├── mutex.rs\n│   ├── rc.rs\n│   └── refcell.rs\n├── lib.rs\n├── spi\n│   └── ... (大致同i2c)\n└── util.rs\n\ncan crate （又单独拉出来了一个crate）\n├── blocking.rs\n├── id.rs\n├── lib.rs\n└── nb.rs\n\nio crate (有两个，一个普通、一个async，文件夹结构相同)\n├── impls\n│   ├── boxx.rs\n│   ├── mod.rs\n│   ├── slice_mut.rs\n│   ├── slice_ref.rs\n│   └── vec.rs\n└── lib.rs\n\nio-adapters crate （io-hal 的实现）\n├── fmt.rs （对core::fmt::write的封装）\n├── futures_03.rs （基于futures crate的实现）\n├── lib.rs\n├── std.rs （对std::read/write的封装）\n└── tokio_1.rs （tokio的实现）\n\n\n\n\nHAL、devicetree or configuration file?"
  },
  {
    "objectID": "posts/rust-os/async-related-os-and-hal.html#axhal",
    "href": "posts/rust-os/async-related-os-and-hal.html#axhal",
    "title": "Rust Embedded OS and HAL about Async",
    "section": "",
    "text": "Note\n\n\n\n\n\n.\n├── arch\n│   ├── aarch64 （arm相关：cortex-m-rt？）\n│   │   └── ...\n│   ├── loongarch64\n│   │   └── ...\n│   ├── mod.rs\n│   ├── riscv （riscv-rt？）\n│   │   └── ...\n│   └── x86_64\n│       └── ...\n├── cpu.rs （core，核心相关）\n├── irq.rs （中断相关）\n├── lib.rs\n├── mem.rs （物理内存管理）\n├── paging.rs （内存分页相关）\n├── platform\n│   └── ... (特定平台的实现)\n├── time.rs \n├── tls.rs (✖线程内存，应由multitask模块提供？)\n└── trap.rs （特权态相关）"
  },
  {
    "objectID": "posts/rust-os/async-related-os-and-hal.html#embedded-hal",
    "href": "posts/rust-os/async-related-os-and-hal.html#embedded-hal",
    "title": "Rust Embedded OS and HAL about Async",
    "section": "",
    "text": "Note\n\n\n\n\n\nmain crate\n├── delay.rs\n├── digital.rs\n├── i2c.rs\n├── lib.rs\n├── pwm.rs\n└── spi.rs\n\nnon-blocking crate\n├── lib.rs\n├── serial.rs\n└── spi.rs\n\nasync crate\n├── delay.rs\n├── digital.rs\n├── i2c.rs\n├── lib.rs\n└── spi.rs\n\nbus crate (提供bus的共享实现)\n├── i2c\n│   ├── atomic.rs\n│   ├── critical_section.rs\n│   ├── mod.rs\n│   ├── mutex.rs\n│   ├── rc.rs\n│   └── refcell.rs\n├── lib.rs\n├── spi\n│   └── ... (大致同i2c)\n└── util.rs\n\ncan crate （又单独拉出来了一个crate）\n├── blocking.rs\n├── id.rs\n├── lib.rs\n└── nb.rs\n\nio crate (有两个，一个普通、一个async，文件夹结构相同)\n├── impls\n│   ├── boxx.rs\n│   ├── mod.rs\n│   ├── slice_mut.rs\n│   ├── slice_ref.rs\n│   └── vec.rs\n└── lib.rs\n\nio-adapters crate （io-hal 的实现）\n├── fmt.rs （对core::fmt::write的封装）\n├── futures_03.rs （基于futures crate的实现）\n├── lib.rs\n├── std.rs （对std::read/write的封装）\n└── tokio_1.rs （tokio的实现）\n\n\n\n\nHAL、devicetree or configuration file?"
  },
  {
    "objectID": "posts/rust-os/async-related-os-and-hal.html#rtic",
    "href": "posts/rust-os/async-related-os-and-hal.html#rtic",
    "title": "Rust Embedded OS and HAL about Async",
    "section": "RTIC",
    "text": "RTIC\nrepo\n\n硬件任务（由中断驱动）\n软件任务（相同优先级的任务共享一个中断内部使用协程，通过中断优先级来保证任务优先级）\n资源（挺有意思的，隐藏了一些资源共享的操作，可读性更强，更规整）\n\nlocal\nshare\n通道\n\nmonotonics 带有timeout的任务，同优先级的任务还是会有实时性问题"
  },
  {
    "objectID": "posts/rust-os/async-related-os-and-hal.html#embassy-preempt",
    "href": "posts/rust-os/async-related-os-and-hal.html#embassy-preempt",
    "title": "Rust Embedded OS and HAL about Async",
    "section": "embassy-preempt",
    "text": "embassy-preempt\n关于桟的一些思考 连续性？\n如果只是实现FIFO以及高优先级直接抢占的话似乎不需要为每个单独的任务分配桟？ 有意思的点在于通过pendsv似乎可以不再依赖有限的软中断\n但是如果需要时间片相关的调度算法(RoundRobin, 各种CFS)还是需要将桟分开来？"
  },
  {
    "objectID": "posts/rust-os/async-related-os-and-hal.html#arielos",
    "href": "posts/rust-os/async-related-os-and-hal.html#arielos",
    "title": "Rust Embedded OS and HAL about Async",
    "section": "ArielOS",
    "text": "ArielOS\n粗略看下来更多强调了通过yml等提供的更灵活的可配置性"
  }
]