[
  {
    "objectID": "posts/systemd-nspawn-dev-env/index.html",
    "href": "posts/systemd-nspawn-dev-env/index.html",
    "title": "the dev environment with systemd-nspawn",
    "section": "",
    "text": "background\nI am an Arch user motivated by its super active community. However, many stuff in academy or industry extremely those about Robotics are designed for the Ubuntu. The ROS AUR package is out-of-date. It is difficult to maintain a package with so many dependencies. Furthermore, many libraries about pointcloud processing and navigation are developed under ubuntu, which means developers of those libs only maintain for Ubuntu usually.\n\n\ncreate Ubuntu environment\n\ndebootstrap\n\nparu -S debootstrap\n\nTo manage the container with machinectl, create the Ubuntu environment in the /var/lib/machines/ with root permission.\n\n\ndebootstrap --include=dbus,systemd-container --components=main,universe,multiverse jammy jammy https://mirrors.tuna.tsinghua.edu.cn/ubuntu\n\nEnter the container with systemd-nspawn -D jammy\nThe network of Ubuntu might be broken now.\n\nconfigure systemd-resolved. Edit the /etc/systemd/resolved.conf DNS line DNS=8.8.8.8\n(optionally) configure DNS manually\n\nsudo systemctl disable --now systemd-resolved\necho 'nameserver 8.8.8.8' &gt; /etc/resolv.conf\n\n\n\nAt first, I tried podman(docker) for a period of time. I think they are so heavy. I don’t care about the image, I just require a container that can run Ubuntu and the faster the better. I don’t mind the dirty directories. That’s why I choose systemd-nspawn in the end\n\n\npassthrough Nvidia GPU\nAnother requirement is the discrete Nvidia gpu on my laptop, some of the development using CUDA. ArchWiki Systemd-nspawn#Nvidia_GPUs Create file /etc/systemd/system/systemd-nspawn@.service.d/nvidia-gpu.conf\n[Service]\nExecStart=\nExecStart=systemd-nspawn --quiet --keep-unit --boot --link-journal=try-guest --machine=%i \\\n--bind=/dev/dri \\\n--bind=/dev/shm \\\n--bind=/dev/nvidia0 \\\n--bind=/dev/nvidiactl \\\n--bind=/dev/nvidia-modeset \\\n--bind=/usr/bin/nvidia-bug-report.sh:/usr/bin/nvidia-bug-report.sh \\\n--bind=/usr/bin/nvidia-cuda-mps-control:/usr/bin/nvidia-cuda-mps-control \\\n--bind=/usr/bin/nvidia-cuda-mps-server:/usr/bin/nvidia-cuda-mps-server \\\n--bind=/usr/bin/nvidia-debugdump:/usr/bin/nvidia-debugdump \\\n--bind=/usr/bin/nvidia-modprobe:/usr/bin/nvidia-modprobe \\\n--bind=/usr/bin/nvidia-ngx-updater:/usr/bin/nvidia-ngx-updater \\\n--bind=/usr/bin/nvidia-persistenced:/usr/bin/nvidia-persistenced \\\n--bind=/usr/bin/nvidia-powerd:/usr/bin/nvidia-powerd \\\n--bind=/usr/bin/nvidia-sleep.sh:/usr/bin/nvidia-sleep.sh \\\n--bind=/usr/bin/nvidia-smi:/usr/bin/nvidia-smi \\\n--bind=/usr/bin/nvidia-xconfig:/usr/bin/nvidia-xconfig \\\n--bind=/usr/lib/gbm/nvidia-drm_gbm.so:/usr/lib/x86_64-linux-gnu/gbm/nvidia-drm_gbm.so \\\n--bind=/usr/lib/libEGL_nvidia.so:/usr/lib/x86_64-linux-gnu/libEGL_nvidia.so \\\n--bind=/usr/lib/libGLESv1_CM_nvidia.so:/usr/lib/x86_64-linux-gnu/libGLESv1_CM_nvidia.so \\\n--bind=/usr/lib/libGLESv2_nvidia.so:/usr/lib/x86_64-linux-gnu/libGLESv2_nvidia.so \\\n--bind=/usr/lib/libGLX_nvidia.so:/usr/lib/x86_64-linux-gnu/libGLX_nvidia.so \\\n--bind=/usr/lib/libcuda.so:/usr/lib/x86_64-linux-gnu/libcuda.so \\\n--bind=/usr/lib/libnvcuvid.so:/usr/lib/x86_64-linux-gnu/libnvcuvid.so \\\n--bind=/usr/lib/libnvidia-allocator.so:/usr/lib/x86_64-linux-gnu/libnvidia-allocator.so \\\n--bind=/usr/lib/libnvidia-cfg.so:/usr/lib/x86_64-linux-gnu/libnvidia-cfg.so \\\n--bind=/usr/lib/libnvidia-egl-gbm.so:/usr/lib/x86_64-linux-gnu/libnvidia-egl-gbm.so \\\n--bind=/usr/lib/libnvidia-eglcore.so:/usr/lib/x86_64-linux-gnu/libnvidia-eglcore.so \\\n--bind=/usr/lib/libnvidia-encode.so:/usr/lib/x86_64-linux-gnu/libnvidia-encode.so \\\n--bind=/usr/lib/libnvidia-fbc.so:/usr/lib/x86_64-linux-gnu/libnvidia-fbc.so \\\n--bind=/usr/lib/libnvidia-glcore.so:/usr/lib/x86_64-linux-gnu/libnvidia-glcore.so \\\n--bind=/usr/lib/libnvidia-glsi.so:/usr/lib/x86_64-linux-gnu/libnvidia-glsi.so \\\n--bind=/usr/lib/libnvidia-glvkspirv.so:/usr/lib/x86_64-linux-gnu/libnvidia-glvkspirv.so \\\n--bind=/usr/lib/libnvidia-ml.so:/usr/lib/x86_64-linux-gnu/libnvidia-ml.so \\\n--bind=/usr/lib/libnvidia-ngx.so:/usr/lib/x86_64-linux-gnu/libnvidia-ngx.so \\\n--bind=/usr/lib/libnvidia-opticalflow.so:/usr/lib/x86_64-linux-gnu/libnvidia-opticalflow.so \\\n--bind=/usr/lib/libnvidia-ptxjitcompiler.so:/usr/lib/x86_64-linux-gnu/libnvidia-ptxjitcompiler.so \\\n--bind=/usr/lib/libnvidia-rtcore.so:/usr/lib/x86_64-linux-gnu/libnvidia-rtcore.so \\\n--bind=/usr/lib/libnvidia-tls.so:/usr/lib/x86_64-linux-gnu/libnvidia-tls.so \\\n# not exist in my machine. --bind=/usr/lib/libnvidia-vulkan-producer.so:/usr/lib/x86_64-linux-gnu/libnvidia-vulkan-producer.so \\\n--bind=/usr/lib/libnvoptix.so:/usr/lib/x86_64-linux-gnu/libnvoptix.so \\\n--bind=/usr/lib/modprobe.d/nvidia-utils.conf:/usr/lib/x86_64-linux-gnu/modprobe.d/nvidia-utils.conf \\\n--bind=/usr/lib/nvidia/wine/_nvngx.dll:/usr/lib/x86_64-linux-gnu/nvidia/wine/_nvngx.dll \\\n--bind=/usr/lib/nvidia/wine/nvngx.dll:/usr/lib/x86_64-linux-gnu/nvidia/wine/nvngx.dll \\\n--bind=/usr/lib/nvidia/xorg/libglxserver_nvidia.so:/usr/lib/x86_64-linux-gnu/nvidia/xorg/libglxserver_nvidia.so \\\n--bind=/usr/lib/vdpau/libvdpau_nvidia.so:/usr/lib/x86_64-linux-gnu/vdpau/libvdpau_nvidia.so \\\n--bind=/usr/lib/xorg/modules/drivers/nvidia_drv.so:/usr/lib/x86_64-linux-gnu/xorg/modules/drivers/nvidia_drv.so \\\n--bind=/usr/share/X11/xorg.conf.d/10-nvidia-drm-outputclass.conf:/usr/share/X11/xorg.conf.d/10-nvidia-drm-outputclass.conf \\\n--bind=/usr/share/dbus-1/system.d/nvidia-dbus.conf:/usr/share/dbus-1/system.d/nvidia-dbus.conf \\\n--bind=/usr/share/egl/egl_external_platform.d/15_nvidia_gbm.json:/usr/share/egl/egl_external_platform.d/15_nvidia_gbm.json \\\n--bind=/usr/share/glvnd/egl_vendor.d/10_nvidia.json:/usr/share/glvnd/egl_vendor.d/10_nvidia.json \\\n--bind=/usr/share/licenses/nvidia-utils/LICENSE:/usr/share/licenses/nvidia-utils/LICENSE \\\n--bind=/usr/share/vulkan/icd.d/nvidia_icd.json:/usr/share/vulkan/icd.d/nvidia_icd.json \\\n--bind=/usr/share/vulkan/implicit_layer.d/nvidia_layers.json:/usr/share/vulkan/implicit_layer.d/nvidia_layers.json \\\nDeviceAllow=/dev/dri rw\nDeviceAllow=/dev/shm rw\nDeviceAllow=/dev/nvidia0 rw\nDeviceAllow=/dev/nvidiactl rw\nDeviceAllow=/dev/nvidia-modeset rw\n\n\nusage\nsudo machinectl start jammy\nsudo machinectl poweroff jammy\nsudo machinectl enable jammy # auto-start\n\n\ninstall package\n\nupdate modify /etc/apt/source.list, add jammy-updates and jammy-backports\n\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse\nthen, \nsudo apt update\n\ncuda\naccording to this, we just need to install the required cuda-toolkit in the container regardless the cuda in the host Arch.\nfollowing Nvidia’s instruction install the specific version of cuda-toolkit.\nros\njust following the ROS wiki everything will work correctly.\n\n\n\nGUI\nUsing Wayland, to use GUI, just let the DISPLAY env in the container equal to its value in the host without binding anything specifically.\n\n\nat least it runs well on my machine\nexport DISPLAY=:1\n\n\nreference\nhttps://wiki.archlinux.org/title/Systemd-nspawn\nhttps://www.kxxt.dev/blog/systemd-nspawn-container-for-ros"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "A Sleepy Student?"
  },
  {
    "objectID": "about.html#who-am-i",
    "href": "about.html#who-am-i",
    "title": "About",
    "section": "",
    "text": "A Sleepy Student?"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hello?",
    "section": "",
    "text": "iterative closest point(icp)\n\n\n \n\n\nnotes\n\n\n \n\n\n\n\n\nOct 20, 2024\ndrindr \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nthe dev environment with systemd-nspawn\n\n\n \n\n\nposts\n\n\n \n\n\n\n\n\nAug 24, 2024\ndrindr \n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/icp/index.html",
    "href": "posts/icp/index.html",
    "title": "iterative closest point(icp)",
    "section": "",
    "text": "TBD\nvideo site\ntarget: align 2 points into the same frame"
  },
  {
    "objectID": "posts/icp/index.html#part1-data-association-svd",
    "href": "posts/icp/index.html#part1-data-association-svd",
    "title": "iterative closest point(icp)",
    "section": "PART1: Data Association & SVD",
    "text": "PART1: Data Association & SVD\n\ndirect and optimal solution: \\(\\sum||y_n - \\bar{x}_n||^2p_n \\rightarrow min\\)\n\nproperties: no initial guess and no better solution exist\nweighted sums: \\(x_0 = \\frac{\\sum x_n p_n}{\\sum p_n}\\) and \\(y_0 = \\frac{\\sum y_n p_n}{\\sum p_n}\\)\ncross-correlation matrix: \\(H = \\sum (y_n - y_0)(x_n - x_0)^T p_n\\)\n\\(svd(H) = UDV^T\\)\n\\(\\Rightarrow R=VU^T, t = y_0 - Rx_0\\)\nuse the local coordinates defined by the point set (set the origin as weighted mean \\(y_0\\))\n\\(\\sum ||(y_n - y_0) - (R x_n + t - y_0)||^2 p_n \\rightarrow min\\)\nstart with \\(\\bar{x}_n - y_0 = Rx_n + t - y_0\\)\nrewrite the translation \\(\\bar{x}n  - y_0 = R(x_n + R^Tt - R^Ty_0)\\)\nintroduce a new variable \\(x_0 = R^Ty_0 - R^Tt\\)\n\\(\\bar{x}_n - y_0 = R(x_n - x_0)\\)\nminimization problem: \\(R^*, x^*_0 = \\underset{R, x_0}{argmin}\\sum || y_n - y_0 - R(x_n - x_0) ||^2 p_n\\)\nobjective function: \\(\\Phi(x_0, R) = \\sum [(y_n - y_0) - R(x_n - x_0)]^T[(y_n - y_0) - R(x_n - x_0)] p_n\\)\nlet \\(\\frac{\\delta \\Phi}{\\delta x_0} = 0 \\Rightarrow x_0 = \\frac{\\sum x_np_n}{p_n}\\)\nthen let \\(\\frac{\\delta \\Phi}{\\delta x_0} = 0 \\Rightarrow R^* = \\underset{R}{argmax}\\sum b_n^TRa_np_n\\) \\((b_n = y_n - y_0, a_n = x_n - x_0)\\)\nusing the trace?: \\(R^* = \\underset{R}{argmax}\\ tr(RH)\\)\n\\(H\\) is the covariance matrix: \\(H = \\sum (a_nb_n^T)p_n\\)"
  },
  {
    "objectID": "posts/icp/index.html#footnotes",
    "href": "posts/icp/index.html#footnotes",
    "title": "iterative closest point(icp)",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nnot understood↩︎"
  }
]